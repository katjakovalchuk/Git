На цьому уроці ми будемо переходити із 32-ох бітової системи на 64-ох бітову (так званий long mode)

Минулого разу ми створили наше середовище ос та вивели 'OK' в лівому верхньому кутку екрану емулятора.

Перше, що нам потрібно зробити, це створити Стек.
Створюємо ми його в main.asm розміром 16Кб.

stack_bottom:
    resb    4096 * 4
stack_top:

Оскільки CPU використовує esp (extended stack pointer) регістр для збереження адреси початку стеку,
то ми маємо її туди записати:
mov  esp, stack_top

Виклик функцій для сетапу 64-бітової ос
call check_multiboot - чи вдалося завантажити систему за допомогою multiboot
call chech_cpuid - чи підтримує процесор функцію CPUID, яка дозволяє дізнатися характеристики процесора
call check_long_mode - чи підтримується long mode

call setup_page_tables - встановлення таблиці сторінок
call enable_paging - дозвіл на утворення сторінок

Давайте по порядку:

check_multiboot:
    cmp eax,  0x36d76289 - магічне число, для перевірки того, 
                            чи була завантажена система за допомогою multiboot
    jne .no_multiboot - якщо система не була завантажена за допомогою multiboot, 
                        то ідемо на прапорець .no_multiboot
    ret - інакше повернення з функції

.no_multiboot:
    mov al, "M" - встановлюємо "M" у регістр al
    jmp error - стрибаємо на виведення помилки


chech_cpuid:
нам потрібно спробувати реверснути значення біту регістру прапорців, і якщо ми можемо це зробити, то 
у нас є доступ до CPUID

chech_cpuid:
    pushfd - зберігає значення всіх прапорців процесора у стек
    pop eax - витягує значення прапорців та зберігає його в eax
    mov ecx, eax - копіює значення прапорця в ecx
    xor eax, 1 << 21 - побітово зміщує прапорці в eax, щоб змінити значення 21 біта на протилежне
    push eax - зберігає нове значення у стек
    popfd - відновлює значення прапорця з вершини стеку
    pushfd - знову зберігає значення прапорця у стек
    pop eax - витягує нове значення прапорця
    push ecx - зберігає оригінальне значення прапорця у стек
    popfd - відновлює значення прапорця з регістру ecx
    cmp eax, ecx - порівнює два значення
    je .no_cpuid - переходить до .no_cpuid якщо значення регістрів однакові
    ret - повертається з функції, якщо CPUID підтримується

.no_cpuid:
    mov al, "C" - записує код помилки в регістр al
    jmp error - стрибає на вивід помилки


check_long_mode:
	mov eax, 0x80000000 - встановлює спеціальне значення eax для запиту про підтримувані функції проесора
	cpuid - записує у eax число, і якщо воно більше за   0x80000000, то CPU підтрммує long mode
	cmp eax, 0x80000001 - порівнюємо значення регістра та числа
	jb .no_long_mode - якщо число менше за 0x80000001, тоді в нас немає long mode режиму

	mov eax, 0x80000001 - встановлює значення в eax
	cpuid - виконує функцію для отримання інформації про підтримку long mode
	test edx, 1 << 29 - перевіряє 29 біт у edx, який вказує, чи підтримується довгий режим, чи ні
	jz .no_long_mode - Якщо немає підтримки long mode - стрибаємо на .no_long_mode
	
	ret

.no_long_mode:
    mov al, "L" - записуємо код помилки в al
    jmp error - стрибаємо на вивід помилки

Далі нам треба зарезервувати у секції .bss наші сторінки пам'яті по 4Кб кожна

section .bss
align 4096
page_table_L4:
    resb 4096
page_table_L3:
    resb 4096
page_table_L2:
    resb 4096

setup_page_tables:
    mov eax, page_table_L3 - завантажує адресу сторінки рівня 3
    or eax, 0b11 ; present, writable - встановлює 0 і 1 біт регістру eax, щоб позначити таблицю як доступну та ту, в яку можна писати
    mov [page_table_L4], eax - зберігає оновлене значення eax у таблиці рівня 4

    mov eax, page_table_L2 - зберігає адресу сторінки рівня 2 у eax
    or eax, 0b11 ; present, writable - встановлює 0 та 1 біт регістру eax, щоб позначити цю сторінку, як доступну
    mov [page_table_L3], eax - зберігає оновлене значення eax у таблиці рівня 3 

    mov ecx, 0 ; counter - створюємо лічильник для циклу

.loop:
	mov eax, 0x200000 ; 2MiB - встановлює величину сторінки на 2Мб
	mul ecx - множимо eax на ecx, щоб отримати адресу початку сторінки
	or eax, 0b10000011 ; present, writable, huge page - встановлює біти, що позначають сторінку як велику і доступну в eax
	mov [page_table_L2 + ecx * 8], eax - зберігає адресу у таблиці сторінок рівня 2

	inc ecx ; increment counter - збільшуємо лічильник
	cmp ecx, 512 ; checks if the whole table is mapped - первіряємо, чи всі таблиці замепились
	jne .loop ; if not, continue - якщо не всі таблиці замепились - ідемо знову в цикл

	ret - повертаємось із функції

enable_paging:
	; pass page table location to cpu
	mov eax, page_table_L4 - завантажує адресу таблиці сторінок рівня 4 у eax
	mov cr3, eax - копіює цю адресу у cr3

	; enable PAE - Physical Address Extension
	mov eax, cr4 - завантажує значення cr4 у eax
	or eax, 1 << 5 - встановлює 5 біт для активації Physical Address Extension (PAE flag)
	mov cr4, eax - зберігає нове значення у регістрі cr4

	; enable long mode
	mov ecx, 0xC0000080 - встановлюємо значення 0xC0000080 у ecx для Model Specific Register 
	rdmsr - зчитує Model Specific Register в eax та edx
	or eax, 1 << 8 - встановлюємо 8 біт для активації long mode
	wrmsr - записує нове значення в MSR 

	; enable paging
	mov eax, cr0 - записує значення cr0 в eax
	or eax, 1 << 31 - встановлює 31 біт для активації сторінкової адресації
	mov cr0, eax - зберігає значення eax у cr0

	ret - вертається з функції

MSR - спеціальний регістр, що використовується для зберігання специфічної інформації для конретної архіьектруи
чи моделі. Дозволяє налаштувати функціональність процесора, отримувати доступ до характеристик, таких як управління ресурсами.
Тут ми його використовуємо для увімкнення long mode.

error:
    ; print "ERR: X" where X is the error code
    mov dword [0xb8000], 0x4f524f45 -|
	mov dword [0xb8004], 0x4f3a4f52   |-  - записує у відеопам'ять число, яке відповідає символам "ERROR"
	mov dword [0xb8008], 0x4f204f20 -|
	mov byte  [0xb800a], al - записує нашу літеру помилки, яку ми хочемо вивести
	hlt - зупиняємо процесор

написавши це все, ми все ще у 32-ох бітовому режимі, а для того, щоб нарешті перейти у 64-ох бітовий
ми маємо створити Global Descriptor Table.

section .read_only_data
gdt64:
	dq 0 ; zero entry - нульовий запис у GDT
.code_segment: equ $ - gdt64 - сегмент коду розміром (поточна адреса - адреса початку gdt64)
	dq (1 << 43) | (1 << 44) | (1 << 47) | (1 << 53) ; code segment - сегмент коду | наявність | виконуваність | привілейованість
.pointer:
	dw $ - gdt64 - 1 ; length - вказівник на GDT, який містить довжину таблиці (від кінця віднімаємо початок і 1)
	dq gdt64 ; address - адреса початку gdt у пам'яті



lgdt [gdt64.pointer] - завантажуємо GDT
jmp gdt64.code_segment:long_mode_start - завантажуємо код у секцію коду
Вітаю нас, ми налаштували все, що нам потрібно для 64-ох бітного режиму, і нарешті можемо почати в ньому щось робити
Для цього ми створюємо main64.asm

global long_mode_start
extern kernel_main

section .text
bits 64 - встановлюємо 64-ох бітний режим
long_mode_start:
    ; load null into all data segment registers
    mov ax, 0
    mov ss, ax
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax - встановлюємо у всі регістри 0, щоб уникнути помилок 

    call kernel_main
    hlt - зупиняє виконання процесора

Тепер ми можемо написати свої C функції для виводу на екраник.
Описувати я їх поки не буду.